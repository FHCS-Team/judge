# Quick guidance for AI contributors — FHCS JUDGE

Keep this short and specific to this repo. Follow these project patterns when writing code, tests, or edits.

- Logging: use the project logger at `src/utils/logger.js` (don't add raw console.log). Example: `const log = require('../utils/logger')` and use `log.info(...)`.

- Tests: mirror `src` into `tests`.
  - Unit tests: `src/foo/bar.js` -> `tests/unit/foo/bar.test.js`.
  - Integration tests: `src/foo/bar.js` -> `tests/integration/foo/bar.test.js`.
  - Use `jest` (scripts: `npm test`, `npm run test:ci`, `npm run test:watch`). Prefer running single suites with `npx jest <path> --runInBand` when iterating.

- Module style: the repo is CommonJS (`package.json` has "type": "commonjs"). Most files use `require()` and `module.exports`. New files should match surrounding files' style.
  - The `package.json` contains an `imports` map for convenient internal aliases (e.g. `#docker/*`, `#queue/*`). Existing code mostly uses relative `require()`; when adding new modules, prefer alias imports if actual import contains more than one `../`. Also update other imports in the file to keep consistency.

- Important directories and their roles (files to read first):
  - `src/index.js` — app entrypoint (start-up wiring)
  - `src/api/server.js` — HTTP health/metrics endpoints
  - `src/messaging/` — `consumer.js`, `publisher.js`, and `handlers/` (message flow)
  - `src/queue/index.js` — in-memory queue implementation + routing rules (registerHandler examples)
  - `src/docker/` — dockerode wrappers: `container.js`, `image.js`, `exec.js`
  - `src/types/schemaRegistry.js` and `src/types/schemas/` — AJV validators for payloads (use `getValidator(name)` to validate payloads)
  - `src/storage/database.js` — persistence layer (better-sqlite3)
  - `src/services/` — higher-level business logic that orchestrates docker + storage

- Message & data flow (high-level):
  1. Incoming submissions or problem packages are published/received via `src/messaging`.
  2. Messages are enqueued in `src/queue` (envelope: id, type, payload, retries, max_retries).
  3. Consumers/handlers (in `src/messaging/handlers`) take messages, call `src/services/*`, and drive Docker operations in `src/docker/*` to evaluate code.
  4. Results are validated against `types/schemas/result_event.js` and published back via `publisher.js`.

- Queue handler conventions (see `src/queue/index.js`):
  - Register handlers with `registerHandler(pattern, fn)` — `pattern` may be exact string, prefix (ends with `.`), wildcard (`*`) or RegExp. Wildcards are converted to RegExp in the implementation.
  - `start(handler)` sets a default handler. Handlers receive `(msg, { ack, nack })` and must call `ack()` or `nack(err)`.
  - Internal retries set `_internal: true` on messages; `enqueue()` throws when `_shutdown` and message not internal.

- Validation: use `getValidator('submissionSchema'|'problemSchema'|'resultPayload')` before enqueueing or publishing. If a validator exists and the payload fails, surface the validation error (this repo prefers throwing rather than enqueueing invalid data).

- External systems and integration points to be aware of:
  - Docker: `dockerode` wrappers in `src/docker/*` — tests mock these in `tests/unit/docker`.
  - Message broker: `amqplib` is included; code supports a RabbitMQ backend in `src/queue` (memory is the default). `src/messaging` contains consumer/publisher that can use AMQP.
  - DB: `better-sqlite3` via `src/storage/database.js` (local DB in data/ by default).

- Developer commands and quick ops:
  - Run tests: `npm test` (all), or `npx jest <file-or-folder> --runInBand` for a single suite.
  - Dev run (with env): `npm run dev` (reads `dev.env`), production: `npm start` (reads `prod.env`).
  - CI/test coverage: `npm run test:ci`.

- Formatting & linting: eslint + prettier are configured. Follow existing code style; don't reformat unrelated files.

- When editing code generated by the agent:
  - Keep changes minimal and localized; preserve public APIs.
  - Add unit tests that follow the repo's structure — aim for a small happy-path test plus 1 edge case.

If anything here is unclear or you want me to expand/shorten sections, tell me which area (architecture, tests, validation, or integrations) and I'll iterate.